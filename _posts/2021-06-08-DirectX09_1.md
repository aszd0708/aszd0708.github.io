---
layout: post
title:  "DirectX11 공부 9일차(Component 패턴)"
date:   2021-06-09
excerpt: "DirectX11 9일차(Component 패턴)"
tag:
- C++
- DirectX
comments: false
---

# Component 패턴

Component 유니티나 언리얼에서 본 그 컴포넌트이다.
* 장점
  * 각자의 기능을 갖고있는 스스로 동작하는 클래스다.
  * 컴포넌트를 뗀다고 해서 오브젝트의 다른 컴포넌트에 영향이 없다.
    * 컴포넌트들끼리 독립적이며, 커플링이 없다.
  * 코드의 의존성을 줄이고 재활용성을 높인다.

* 단점
  * 지나치게 자유로워서 클레스의 구성요소에 제약을 가하기 힘듦

이러한 이유로 인해 다양한 곳에 사용되고 있다고 한다.

당장 유니티나 언리얼을 실행시키면 컴포넌트 패턴을 사용하고 있다.

이번엔 유니티에 적용한 컴포넌트대로 제작해 보려 한다.

## Component.h
생각보다 컴포넌트에는 많은 데이터가 없다.

다만 컴포넌트를 갖고있는 오브젝트는 할게 많지....

```
#pragma once

enum class ComponentType : uint
{
	Unknown,
	Camera,
	Transform
};

class IComponent
{
public:
	template <typename T>
	static constexpr ComponentType DeduceComponenetType();

public:
	IComponent(class Actor* const actor, class Transform* const transform);
	virtual ~IComponent() = default;

	virtual void Initialize() = 0;
	virtual void Update() = 0;
	virtual void Destroy() = 0;

	Actor* GetActor() const { return actor; }
	void SetActor(class Actor* const actor) { this->actor = actor; }

	Transform* GetTransform() const { return transform; }
	void SetTransform(class Transform* const transform) { this->transform = transform; }

	ComponentType GetComponentType() const { return component_type; }
	void SetComponentType(const ComponentType& component_type) { this->component_type = component_type; }

	bool IsEnabled() const { return is_enabled; }
	void SetEnabled(const bool& is_enabled) { this->is_enabled = is_enabled; }

protected:
	class Actor* actor = nullptr;
	class Transform* transform = nullptr;

	ComponentType component_type = ComponentType::Unknown;
	bool is_enabled = true;
};
```
이 컴포넌트 클래스는 이 클래스를 상속받아 사용하는 클래스이기 때문에 추상 클래스로 만든다.

## Component.h


## 




```
#include "stdafx.h"
#include "IComponent.h"

IComponent::IComponent(Actor* const actor, Transform* const transform)
	:actor(actor)
	,transform(transform)
{
}

template<typename T>
constexpr ComponentType IComponent::DeduceComponenetType()
{
	return ComponentType::Unknown;
}

// explicite template instantiation
#define REGISTER_COMPONENT_TYPE(T, enum_type) template <>ComponentType IComponent::DeduceComponenetType<T>(){	return enum_type; }
```
```
#define REGISTER_COMPONENT_TYPE(T, enum_type) template <>ComponentType IComponent::DeduceComponenetType<T>(){	return enum_type; }
```
이부분은
```
template <typename T>
ComponentType IComponent::DeduceComponenetType<T>()
{	
	return enum_type; 
}
```
이 코드를 매크로로 만든것이다. 

## 충돌 실행
Update()
```
if (Intersect::IsIntersect(player, monster))
{
	player->Event();
	monster->Event();
}
```

이 함수를 Update에 추가하고,

### 색 변경


Rect.h
```

struct COLOR_DATA
{
	D3DXCOLOR color;
};
.
.
.
virtual void Event() = 0;
```

이벤트 함수를 가상함수로 만들고 각각 정의해주자

충돌시 Player의 색을 바꾸고 Monster는 IsActive를 꺼준다.

Rect.cpp에 있는 Update에 이 함수를 추가해서 실시간으로 색이 바뀔 수 있도록 한다.
```
COLOR_DATA* color_data = color_buffer->Map<COLOR_DATA>();
{
	color_data->color = intersect_color;
}
color_buffer->UnMap();	
```
Render()부분에 이것도 추가한다. 그 뒤,
```
pipeline->SetConstantBuffer(2, ShaderScope_PS, color_buffer);
```
셰이더에
```
cbuffer ColorBuffer : register(b2)
{
    float4 color;
};

float4 PS(PixelInput input) : SV_Target		// SV_Target 현제 세팅된 메인 렌더 타렛을 사용하라고 알려줌
{
    return input.color * color;
}
```

PS 부분에 바꾸고 컬러버퍼를 새로 만들어준다.

이렇게 하면,

<img src = "../assets/img/project/d3dx/day8/eatting.gif" width="30%" height="30%">

잘 먹는다.

# 잡생각
그러면 렌더링을 안한다고 해도 업데이트에서 계속해서 버퍼에 데이터를 쌓아두는데 괜찮은가??

이건 하면서 고쳐보자