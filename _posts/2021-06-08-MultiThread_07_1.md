---
layout: post
title:  "Multi Thread 공부 6일차 (List - Non-Blocking(비멈춤 동기화))"
date:   2021-06-14
excerpt: "Multi Thread 공부 6일차 (List - Non-Blocking(비멈춤 동기화))"
tag:
- C++
- Multi Thread
comments: false
---

# List
지금까지 여러 동기화 방법을 알아봤다. 하지만 가장 좋은것은 lock을 하지 않고 만드는게 가장 빠르지만 가장 손실이 많이 났다.

그럼 현실에서 사용되고 있는 멀티스레드 방법을 알아보자

* 현실의 멀티스레드 프로그램은?
	* 여러 스레드가 동시에 멀티코어에서 실행된다.
	* 스레드간의 데이터 공유 및 도익화는 안전한 lock free 자료구조를 통해서 이루어진다
		* 언리얼 3 : 디스플레이 리스트 queue
		* 각종 게임 서버 : job queue 외 다수

현실에서 멀티스레드 프로그램은 스레드 간에 데이터 공유 및 동기화는 안전한 lock free 자료구조로 해야 한다. 언리얼 3,4같은 경우는 멀티스레드로 만든 엔진인데 스레드끼리 서로 queue로 주고 받는다. 로직 스레드에서 actor들을 최신으로 만들면 렌더링 스레드에서 업데이트 한다.

그리고 게임서버 회사에서 구현한 서버들은 락프리 자료구조를 사용한다. 랃프리 자료구조를 사용하지 않으면 성능이 안나온다.

그래서 락프리가 뭐냐

## Lock Free
* 여러개의 스레드에서 동시에 호출했을 때에도 정해진 단위 시간마다 적어도 한 개의 호출이 완료되는 알고리즘
* 자료구조 및 그것에 대한 접근 방법
	* queue : enqueue, dequeue
	* stack : push, pop
	* 이진트리 : insert, delete, search
* **멀티스레드에서 동시에 호출해도 정확한 결과를 만들어주는 알고리즘**
	* stl 탈락
* **Non-Blocking 알고리즘**
	* 다른 스레드가 어떤 상태에 있건 상관없이 호출이 완료된다.
* **호출이 다른 스레드와 충돌하였을 경우 적어도 하나의 승자에 있어서, 승자는 delay없이 완료된다.**

여기서 략프리는 볼드체의 3개자 조건을 만족시키는 알고리즘이다.

따라서 stl에서 사용하고 있는 자료구조 큐, 벡터, 맵은 전부 사용하지 못한다. atomic하지 않기 때문에 멀티스레드에서 제대로 돌아가지 못한다.(직접 만들어야 한다.)

그 다음엔 Non-Blocking 해야 한다. 어떤 뜻이냐면, 여러 스레드가 동시에 호출해야 하는데 다른 스레드에서 메소드를 실행하면서 어떤 상태에 처해있건 상관없이 호출이 완료되는 알고리즘이다. 옆에 스레드가 어떤 상황이든 내걸 건들이든 말든 호출이 완료 되어야 한다.

만약 충돌했으면 어떻게 되냐? 그냥 끝내면 된다. lock free는 충돌하면 둘중 하나는 딜레이가 생기지만 하나는 그냥 완료 해야 한다.